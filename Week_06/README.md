# 第六周学习笔记

```python
动态规划（英语：Dynamic programming，DP）[1]是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题[2]和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。
```



## 动态规划解题的一般思路

能采用动态规划求解的问题的一般要具有3个性质：
**(1) 最优化原理**：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
**(2) 无后效性** ：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
**(3)有重叠子问题**：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）

用动态规划解题，如何寻找“子问题”，定义“状态”，“状态转移方程”是什么样的，并没有一定之规，需要具体问题具体分析，题目做多了就会有感觉。
甚至，对于同一个问题，分解成子问题的办法可能不止一种，因而“状态”也可以有不同的定义方法。不同的“状态”定义方法可能会导致时间、空间效率上的区别。



## 例子1：

给定一个三角形 triangle ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

 ```python
示例1：
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
 ```



想要找到自定向下的最小路径和，那么可以找第一层节点的子节点的最小路径，再找子节点的子节点的最小路径。

其实也可以反过来考虑：

先找到6这个节点的最小路径，找到5这个节点的最小路径，7这个节点的最小路径

再找3这个节点的最小路径，4这个节点的最小路径，

那么最终可以得到2这个节点的最小路径

```python
for i in range(len(triangle)-2,-1,-1):
            for j in range(len(triangle[i])):
                # print(i, j)
                triangle[i][j] = min(triangle[i+1][j] + triangle[i][j], triangle[i+1][j+1] + triangle[i][j])
        return triangle[0][0]
```



## 例子2：

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

```python
示例1：
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

```python
示例2:
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```



根据归纳法可以发现想要到第n级台阶，可以从n-1级台阶和n-2级台阶上来，

既到n级台阶的走法为到n-1级台阶的走法+n-2级台阶的走法

类似于斐波那契数列，可以加个缓存减少时间复杂度

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        i, j, k = 1, 2, 0
        for num in range(2, n):
            k = i + j
            i = j
            j = k
        return max(n, k)
```



## 例子3:

最小路径和

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

```python
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。

1   3   1
1   5   1
4   2   1
```



因为每次只能向下或者向右走，想要寻找最小路径

所以当前节点最小路径为min(从左边往右边走的路径，从上边走下来的路径)

定义dp数组之后，对第一行和第一列的只能有一条路径，其他的按dp方程来计算，得到最终的解

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:

        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i == j == 0 : continue
                elif i == 0: grid[i][j] = grid[i][j - 1] + grid[i][j] 
                elif j == 0: grid[i][j] = grid[i - 1][j] + grid[i][j]
                else: grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j]
        return grid[-1][-1]
```



